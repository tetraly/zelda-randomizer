from typing import Dict, List, Tuple
import random
from absl import logging
from .cave import Cave
from .constants import Direction, Item, LevelNum, Range, RoomNum
#from .data import *  TODO: Do I need this at runtime?
from .room import Room
from .location import Location
from .patch import Patch
from .screen import Screen


def IsStartOfColumn(data: int) -> bool:
  assert data & 0x80 == 0x00 or data & 0x80 == 0x80
  return data & 0x80 == 0x80


def IsPassable(tile_code: int) -> bool:
  # List of Water codes
  if tile_code in [0x05, 0x06, 0x07, 0x08, 0x09, 0x15, 0x16, 0x17, 0x18, 0x2e, 0x2f]:
    return False
  elif int(tile_code / 16) == 0 or tile_code == 0x37:
    return True
  return False


  # Given a list of either 11 or 16 tile codes, returns their integer mask
def GetIntegerMaskForTileCodes(tile_codes: List[int]) -> int:
  num_tile_codes = len(tile_codes)
  assert num_tile_codes in [11, 16]
  mask: int = 0
  for tile_code_num in range(0, num_tile_codes):
    if IsPassable(tile_codes[tile_code_num]):
      mask += 2**tile_code_num
  assert mask < 2**16
  return mask


class DataTable():
  NES_FILE_OFFSET = 0x10
  OVERWORLD_DATA_START_ADDRESS = 0x18400 + NES_FILE_OFFSET
  LEVEL_1_TO_6_DATA_START_ADDRESS = 0x18700 + NES_FILE_OFFSET
  LEVEL_7_TO_9_DATA_START_ADDRESS = 0x18A00 + NES_FILE_OFFSET
  LEVEL_TABLE_SIZE = 0x80
  NUM_BYTES_OF_DATA_PER_SCREEN = 5
  NUM_BYTES_OF_DATA_PER_ROOM = 6
  CAVE_ITEM_DATA_START_ADDRESS = 0x18600 + NES_FILE_OFFSET
  CAVE_PRICE_DATA_START_ADDRESS = 0x1863C + NES_FILE_OFFSET
  CAVE_NUMBER_REPRESENTING_ARMOS_ITEM = 0x14
  CAVE_NUMBER_REPRESENTING_COAST_ITEM = 0x15
  ARMOS_ITEM_ADDRESS = 0x10CF5 + NES_FILE_OFFSET
  COAST_ITEM_ADDRESS = 0x1788A + NES_FILE_OFFSET
  COMPASS_ROOM_NUMBER_ADDRESS = 0x1942C + NES_FILE_OFFSET
  SPECIAL_DATA_LEVEL_OFFSET = 0xFC

  CAVE_ITEM_DATA_OFFSET = 0x200
  CAVE_PRICE_DATA_OFFSET = 0x23C

  # Generated based on data from disassembly, bank 6 0x19D0F
  COLUMN_GROUP_STARTING_ADDRESSES: List[int] = [
      0x00, 0x35, 0x66, 0xa8, 0xec, 0x11e, 0x15a, 0x195, 0x1d0, 0x20e, 0x24f, 0x294, 0x2d1, 0x307,
      0x349, 0x37d
  ]

  # Generated by running:
  # f = open("vanilla-z1-rom.nes", "rb")
  # for a in range(0, 9):
  #   f.seek(0x1942B + 0x10 + 0xfc * a)
  #   print ("%x" % int.from_bytes(f.read(1), byteorder="big"))
  LEVEL_START_ROOM_NUMBERS = [
      RoomNum(0x73),
      RoomNum(0x7d),
      RoomNum(0x7c),
      RoomNum(0x71),
      RoomNum(0x76),
      RoomNum(0x79),
      RoomNum(0x79),
      RoomNum(0x7e),
      RoomNum(0x76)
  ]

  STAIRCASE_LISTS: Dict[int, List[RoomNum]] = {
      1: [RoomNum(0x7f)],
      2: [],
      3: [RoomNum(0x0f)],
      4: [RoomNum(0x60)],
      5: [RoomNum(0x07), RoomNum(0x04)],
      6: [RoomNum(0x08), RoomNum(0x75)],
      7: [RoomNum(0x7b), RoomNum(0x4a)],
      8: [RoomNum(0x2f), RoomNum(0x0f), RoomNum(0x6f)],
      9: [
          RoomNum(0x60),
          RoomNum(0x70),
          RoomNum(0x72),
          RoomNum(0x75),
          RoomNum(0x67),
          RoomNum(0x77),
          RoomNum(0x00),
          RoomNum(0x4f)
      ]
  }

  def __init__(self) -> None:
    self.level_1_to_6_raw_data = list(
        open("randomizer/randomizer/data/level-1-6-data.bin", 'rb').read(0x300))
    self.level_7_to_9_raw_data = list(
        open("randomizer/randomizer/data/level-7-9-data.bin", 'rb').read(0x300))
    self.overworld_raw_data = list(
        open("randomizer/randomizer/data/overworld-data.bin", 'rb').read(0x300))

    # TODO: Delete this if no longer needed
    #    self.overworld_cave_raw_data = list(
    #        open("randomizer/randomizer/data/overworld-cave-data.bin", 'rb').read(0x80))

    self.column_raw_data = list(
        open("randomizer/randomizer/data/overworld-column-data.bin", 'rb').read(0x3C4))
    self.screen_raw_data = list(
        open("randomizer/randomizer/data/overworld-screen-data.bin", 'rb').read(0x7C0))

    self.level_1_to_6_rooms: List[Room] = []
    self.level_7_to_9_rooms: List[Room] = []
    self.overworld_screens: List[Screen] = []
    self.overworld_caves: List[Cave] = []

    # Screen code -> List of 16 integer column codes for the screen
    self.screen_column_codes: Dict[int, List[int]] = {}
    # Column code -> List of 11 integer tile codes
    self.column_tile_codes: Dict[int, List[int]] = {}
    # Screen_code and edge of screen -> int representing passability mask
    self.screen_edge_masks: Dict[Tuple[int, Direction], int] = {}
    self.triforce_locations: Dict[LevelNum, RoomNum] = {}
    self._ReadDataForColumnDefinitions()
    self._ReadDataForScreenDefinitions()
    self._GenerateScreenEdgeMasks()

  def ResetToVanilla(self) -> None:
    self.level_1_to_6_rooms = self._ReadDataForLevelGrid(self.level_1_to_6_raw_data)
    self.level_7_to_9_rooms = self._ReadDataForLevelGrid(self.level_7_to_9_raw_data)
    self._ReadDataForOverworldGrid()
    self._ReadDataForOverworldCaves()
    self.triforce_locations = {}

  def _ReadDataForLevelGrid(self, level_data: List[int]) -> List[Room]:
    rooms: List[Room] = []
    for room_num in Range.VALID_ROOM_NUMBERS:
      room_data: List[int] = []
      for byte_num in range(0, self.NUM_BYTES_OF_DATA_PER_ROOM):
        room_data.append(level_data[byte_num * self.LEVEL_TABLE_SIZE + room_num])
      rooms.append(Room(room_data))
    return rooms

  def _ReadDataForOverworldGrid(self) -> None:
    for screen_num in Range.VALID_ROOM_NUMBERS:
      screen_data: List[int] = []
      for byte_num in [0, 1, 2, 3, 5]:
        screen_data.append(self.overworld_raw_data[byte_num * self.LEVEL_TABLE_SIZE + screen_num])
      self.overworld_screens.append(Screen(screen_data))

  def _ReadDataForOverworldCaves(self) -> None:
    self.overworld_caves = []
    for cave_num in Range.VALID_CAVE_NUMBERS:
      if cave_num == self.CAVE_NUMBER_REPRESENTING_ARMOS_ITEM:
        self.overworld_caves.append(Cave([0x3F, Item.POWER_BRACELET, 0x7F, 0x00, 0x00, 0x00]))
      elif cave_num == self.CAVE_NUMBER_REPRESENTING_COAST_ITEM:
        self.overworld_caves.append(Cave([0x3F, Item.HEART_CONTAINER, 0x7F, 0x00, 0x00, 0x00]))
      else:
        assert cave_num in range(0, 0x14)
        cave_data: List[int] = []
        for item_num in range(0, 3):
          address_for_item = (3 * cave_num) + item_num
          cave_data.append(self.overworld_raw_data[self.CAVE_ITEM_DATA_OFFSET + address_for_item])
        for item_num in range(0, 3):
          address_for_item = (3 * cave_num) + item_num
          cave_data.append(self.overworld_raw_data[self.CAVE_PRICE_DATA_OFFSET + address_for_item])
        self.overworld_caves.append(Cave(cave_data))
    assert len(self.overworld_caves) == 22  # 0-19 are actual caves, 20-21 are for the armos/coast

  def _ReadDataForColumnDefinitions(self) -> None:
    for column_group_number in range(0, 0x10):
      # Figure out what addresses column definitions start on
      # Start addresses are denoted by having a 1 for the MSB of the data
      searching_address = self.COLUMN_GROUP_STARTING_ADDRESSES[column_group_number]
      column_start_addresses: List[int] = []
      for column_number in range(0, 0x0A):
        while True:
          found_start = IsStartOfColumn(self.column_raw_data[searching_address])
          if found_start:
            column_start_addresses.append(searching_address)
          searching_address += 1
          if found_start:
            break

      for column_number in range(0, 0x0A):
        addr = column_start_addresses[column_number]
        tile_codes: List[int] = []
        num_tile_codes_read: int = 0

        assert self.column_raw_data[addr] & 0x80 == 0x80
        while num_tile_codes_read < 11:
          tile_code = self.column_raw_data[addr] & 0x3F
          if self.column_raw_data[addr] & 0x40 == 0x40:
            tile_codes.extend([tile_code, tile_code])
            num_tile_codes_read += 2
          else:
            tile_codes.append(tile_code)
            num_tile_codes_read += 1
          addr += 1
        assert num_tile_codes_read == 11

        self.column_tile_codes[0x10 * column_group_number + column_number] = tile_codes

  # Now, we have all of our tile data.  Time to parse the screen definitions
  def _ReadDataForScreenDefinitions(self) -> None:
    for screen_code in range(0, 0x7D):
      screen_column_definition = (self.screen_raw_data[0x10 * screen_code:0x10 * (screen_code + 1)])
      self.screen_column_codes[screen_code] = screen_column_definition

  # PleaseAlsoGiveThisABetterImplementation
  def _GenerateScreenEdgeMasks(self) -> None:
    for screen_code in range(0, 0x7A):
      for direction in [Direction.WEST, Direction.EAST]:
        column_num = 0 if direction == Direction.WEST else -1
        column_code = self.screen_column_codes[screen_code][column_num]
        mask = GetIntegerMaskForTileCodes(self.column_tile_codes[column_code])
        self.screen_edge_masks[(screen_code, direction)] = mask
      for direction in [Direction.NORTH, Direction.SOUTH]:
        row_num = 0 if direction == Direction.NORTH else -1
        tile_codes: List[int] = []
        for column_code in self.screen_column_codes[screen_code]:
          tile_codes.append(self.column_tile_codes[column_code][row_num])
        assert len(tile_codes) == 16
        mask = GetIntegerMaskForTileCodes(tile_codes)
        self.screen_edge_masks[(screen_code, direction)] = mask
      print("Masks for screen %d (N,E,S,W):  %d, %d, %d, %d" %
            (screen_code, self.screen_edge_masks[(screen_code, Direction.NORTH)],
             self.screen_edge_masks[(screen_code, Direction.EAST)],
             self.screen_edge_masks[(screen_code, Direction.SOUTH)],
             self.screen_edge_masks[(screen_code, Direction.WEST)]))

  def ShuffleOverworld(self) -> None:
    random.shuffle(self.overworld_screens)

  def GetRoom(self, level_num: LevelNum, room_num: RoomNum) -> Room:
    assert level_num in Range.VALID_LEVEL_NUMBERS
    assert room_num in Range.VALID_ROOM_NUMBERS

    if level_num in [7, 8, 9]:
      return self.level_7_to_9_rooms[room_num]
    return self.level_1_to_6_rooms[room_num]

  def GetRoomItem(self, location: Location) -> Item:
    assert location.IsLevelRoom()
    if location.GetLevelNum() in [7, 8, 9]:
      return self.level_7_to_9_rooms[location.GetRoomNum()].GetItem()
    return self.level_1_to_6_rooms[location.GetRoomNum()].GetItem()

  def SetRoomItem(self, location: Location, item: Item) -> None:
    assert location.IsLevelRoom()
    if location.GetLevelNum() in [7, 8, 9]:
      self.level_7_to_9_rooms[location.GetRoomNum()].SetItem(item)
    else:
      self.level_1_to_6_rooms[location.GetRoomNum()].SetItem(item)

  def GetCaveItem(self, location: Location) -> Item:
    assert location.IsCavePosition()
    return self.overworld_caves[location.GetCaveNum()].GetItemAtPosition(location.GetPositionNum())

  def SetCaveItem(self, location: Location, item: Item) -> None:
    assert location.IsCavePosition()
    self.overworld_caves[location.GetCaveNum()].SetItemAtPosition(item, location.GetPositionNum())

  def UpdateTriforceLocation(self, location: Location) -> None:
    room_num = location.GetRoomNum()
    room = self.GetRoom(location.GetLevelNum(), room_num)
    if room.IsItemStaircase():
      room_num = room.GetLeftExit()
    self.triforce_locations[location.GetLevelNum()] = room_num

  def ClearAllVisitMarkers(self) -> None:
    logging.debug("Clearing Visit markers")
    for room in self.level_1_to_6_rooms:
      room.ClearVisitMark()
    for room in self.level_7_to_9_rooms:
      room.ClearVisitMark()

  # Gets the Room number of the start screen for a level.
  def GetLevelStartRoomNumber(self, level_num: LevelNum) -> RoomNum:
    assert level_num in Range.VALID_LEVEL_NUMBERS
    return self.LEVEL_START_ROOM_NUMBERS[level_num - 1]

  # Gets a list of staircase rooms for a level.
  #
  # Note that this will include not just passage staircases between two
  # dungeon rooms but also item rooms with only one passage two and
  # from a dungeon room.
  def GetLevelStaircaseRoomNumberList(self, level_num: LevelNum) -> List[RoomNum]:
    assert level_num in Range.VALID_LEVEL_NUMBERS
    return self.STAIRCASE_LISTS[level_num]

  def GetPatch(self) -> Patch:
    patch = Patch()
    patch += self._GetPatchForLevelGrid(self.LEVEL_1_TO_6_DATA_START_ADDRESS,
                                        self.level_1_to_6_rooms)
    patch += self._GetPatchForLevelGrid(self.LEVEL_7_TO_9_DATA_START_ADDRESS,
                                        self.level_7_to_9_rooms)
    patch += self._GetPatchForOverworldCaveData()
    patch += self._GetPatchForOverworldGrid()
    return patch

  def _GetPatchForOverworldGrid(self) -> Patch:
    patch = Patch()
    for screen_num in Range.VALID_ROOM_NUMBERS:
      screen_data = self.overworld_screens[screen_num].GetRomData()
      assert len(screen_data) == self.NUM_BYTES_OF_DATA_PER_SCREEN

      for table_num in [0, 1, 2, 3, 5]:
        patch.AddData(
            self.OVERWORLD_DATA_START_ADDRESS + table_num * self.LEVEL_TABLE_SIZE + screen_num,
            [screen_data[table_num if table_num < 5 else 4]])
    return patch

  def _GetPatchForLevelGrid(self, start_address: int, rooms: List[Room]) -> Patch:
    patch = Patch()
    for room_num in Range.VALID_ROOM_NUMBERS:
      room_data = rooms[room_num].GetRomData()
      assert len(room_data) == self.NUM_BYTES_OF_DATA_PER_ROOM

      for table_num in range(0, self.NUM_BYTES_OF_DATA_PER_ROOM):
        patch.AddData(start_address + table_num * self.LEVEL_TABLE_SIZE + room_num,
                      [room_data[table_num]])
    # Write Triforce room location to update where the compass displays it in levels 1-8.
    # The room the compass points to in level 9 doesn't change.
    for level_num in range(1, 9):
      assert level_num in self.triforce_locations
      patch.AddData(
          self.COMPASS_ROOM_NUMBER_ADDRESS + (level_num - 1) * self.SPECIAL_DATA_LEVEL_OFFSET,
          [self.triforce_locations[level_num]])
    return patch

  def _GetPatchForOverworldCaveData(self) -> Patch:
    patch = Patch()
    for cave_num in Range.VALID_CAVE_NUMBERS:
      if cave_num == self.CAVE_NUMBER_REPRESENTING_ARMOS_ITEM:
        patch.AddData(self.ARMOS_ITEM_ADDRESS,
                      [self.overworld_caves[cave_num].GetItemAtPosition(2)])
        continue
      if cave_num == self.CAVE_NUMBER_REPRESENTING_COAST_ITEM:
        patch.AddData(self.COAST_ITEM_ADDRESS,
                      [self.overworld_caves[cave_num].GetItemAtPosition(2)])
        continue

      # Note that the Cave class is responsible for protecting bits 6 and 7 in its item data
      patch.AddData(self.CAVE_ITEM_DATA_START_ADDRESS + (3 * cave_num),
                    self.overworld_caves[cave_num].GetItemData())
      patch.AddData(self.CAVE_PRICE_DATA_START_ADDRESS + (3 * cave_num),
                    self.overworld_caves[cave_num].GetPriceData())
    return patch
